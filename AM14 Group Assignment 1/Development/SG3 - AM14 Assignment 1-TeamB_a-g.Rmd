---
title: "AM14 Assignment 1"
subtitle:  "Prices, Returns, and Portfolio Theory"
author: "Study Group 3: Alberto Lambert, Sammy Chen, Shuhan Li, Michael Gritzbach, Mehek Khanna"
output: html_document
---

------------------------

# OUR STRATEGY

## DEADLINE

IDEAL DEADLINE = 21:00 SUNDAY 17TH JANUARY 2021
INTERNAL DEADLINE = 21:00 WEDNESDAY 20TH JANUARY 2021
OFFICIAL DEADLINE = 21:00 FRIDAY, 22ND JANUARY 2021

## TEAMS

### TEAM A: Q1-Q12 - Sammy & Alberto
### TEAM B: Q13-Q15 - Michael, Mehek & Shuhan

### (SUNDAY 17TH JANUARY)

TEAM A: ASSISTANCE
TEAM B: Q13-Q15 FINALISATION

### (MONDAY 18TH JANUARY)

TEAM A: ASSISTANCE
TEAM B: Q13-Q15 FINALISATION

-------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importing Packages

```{r load_libraries}
library(readxl)
library(tidyverse)
library(lubridate)
library(PerformanceAnalytics)
library(ggthemes)
library(ggtext)
library(patchwork)

```

# QUESTION 1

> 1. Go to CANVAS and download the data for PS1 Monthly.xlsx. The data was downloaded from the CRSP (The Center for Research in Security Prices) data base via WRDS (Wharton Research Service) that is available for LBS students. Note the file contains data about Microsoft, Exxon Mobil (previously Exxon), General Electric, JP Morgan Chase (previously Chemical Banking and Chase Manhattan), Intel, Citigroup (previously Primerica and Travellers Group). In addition, the columns vwretd (ewretd) and vwredx (ewretx) contain value-weighted (equal-weighted) total returns and total returns excluding dividends for the CRSP index that contains stocks from NYSE, AMEX, and NASDAQ. Finally, sprtrn contains the total return for the S&P 500 Composite Index.

```{r loading_monthly_data}

#loading in PS1 monthly data
PS1_Monthly <- read_excel("PS1_Monthly.xlsx") %>% 
  mutate(DATE = lubridate::ymd(date)) %>% #fix `date`
  select(1,2,19,3:18) #reorder the columns logically

#addressing missingness in DIVAMT by imputing with 0
PS1_Monthly[is.na(PS1_Monthly)] <- 0

```

# QUESTION 2

> 2. Make sure you understand how the holding period returns (RET) are calculated given the (unadjusted) prices (PRC), dividends (DIVAMT) and adjustment for the number of shares (CFACPR, i.e., the adjusted price equals PRC/CFACPR). That is, replicate the returns using the raw data. You can find more information about the variables on the CRSP page online. Calculate returns where you omit the dividends, i.e., you focus solely on capital gains (call these returns RETX).

```{r creating_testing_dataframe}

#creating a testing data frame
testing <- PS1_Monthly %>% 
  select(3,4,9,7,13,10,14)

```

**The Calculation of Holding Period Returns (RET) is as follows:**

$RET_t \ = \ \frac{(PRC_t/CFACPR_t)+DIVAMT_t}{PRC_{t-1}/CFACPR_{t-1}}-1$  

where $PRC_t/CFACPR_t$ is the share-adjusted stock price at time $t$, and $DIVAMT_t$ is the dividend payout at time t. 

**Creating a RET Calculator**
```{r calculating_RET}

#creating a function to calculate RET with the arguments: (I) price (PRC), (II) dividends (DIVAMT) and number of shares adjustment (CFACPR)
RET_calculator <- function(PRC, DIVAMT, CFACPR) {
  
  #copying the price column of the data frame
  RET = PRC
  
  #setting first period returns to zero
  RET[1] = 0 
  
  #looping over the rows to calculate and assign values to RET 
  for (n in 2:length(PRC)) {
    
    #calculating RET using the stated formula
    RET[n] = round(((PRC[n]/CFACPR[n] + DIVAMT[n])/(PRC[n-1]/CFACPR[n-1]) - 1),6)
  }
  
  #outputting the RET vector
  return(RET)
}

```

*Testing the RET Calculator**
```{r testing_RET_calculator}

#testing the RET calculator for all the stocks in the data frame
testing<-testing %>% 
  group_by(TICKER) %>% 
  mutate(RET_rep = RET_calculator(PRC, DIVAMT, CFACPR))

#evaluating whether the RET calculation has been accurate
summary(testing$RET==testing$RET_rep)

#consequently, we find that in the vast majority of cases (1519) this calculation is successful - though in 298 instances the calculated RET_rep is not identical, suggesting our formulation is imperfect

```

**The Calculation of Holding Period Returns, Omitting Dividends (RETX) is as follows:**

$RETX_t \ = \ \frac{PRC_t/CFACPR_t}{PRC_{t-1}/CFACPR_{t-1}}-1$  

where $PRC_t/CFACPR_t$ is the share-adjusted stock price at time $t$.

We now repeat the same calculation process, omitting DIVAMT from the equation. 

**Creating a RETX Calculator**
```{r calculating_RETX}

#creating a function to calculate RETX with the arguments: (I) price (PRC), and (II) number of shares adjustment (CFACPR)
RETX_calculator <- function(PRC, CFACPR) {
  
  #copying the price column of the data frame
  RETX = PRC
  
  #setting first period returns to zero
  RETX[1] = 0 
  
  #looping over the rows to calculate and assign values to RETX 
  for (n in 2:length(PRC)) {
    
    #calculating RETX using the stated formula
    RETX[n] = round(((PRC[n]/CFACPR[n])/(PRC[n-1]/CFACPR[n-1]) - 1),6)
  }
  
  #outputting the RETX vector
  return(RETX)
}

```

**Testing the RETX Calculator**
```{r testing_RETX_calculator}

#testing the RET calculator for all the stocks in the data frame
testing<-testing %>% 
  group_by(TICKER) %>% 
  mutate(RETX_rep = RETX_calculator(PRC, CFACPR))

#evaluating whether the RET calculation has been accurate
summary(testing$RETX==testing$RETX_rep)

#consequently, we find that in the vast majority of cases (1755) this calculation is successful - though in 62 instances the calculated RETX_rep is not identical, suggesting our formulation is imperfect

```

# QUESTION 3

> 3. Use the holding period returns to create a total return index for the MSFT and GE stocks and the S&P 500 index, which shows the theoretical growth in value of an investment in the stock assuming that dividends are reinvested (normalize the start value to 1). Do the same for the returns that abstract from dividend payments (i.e., use RETX instead). Plot the investments with and without dividends for each stock separately. How do dividends affect the results stock by stock?

The total return index for a given stock is: $Price_t = Price_{t-1}(1+Return_t)$

**Applying a Cumulative Product Approach to Calculate Total Return Indexes**
```{r creating_total_RET/RETX_indexes}

#creating the total return index for MSFT
MSFT_monthly <-PS1_Monthly %>% 
  group_by(TICKER) %>% 
  filter(TICKER=="MSFT") %>% 
  mutate(
    
    TR_RET = cumprod(1*(1+RET)),
    TR_RETX = cumprod(1*(1+RETX)),
    TR_SP500 = cumprod(1*(1+sprtrn)),
        
         )

#using the TR function to create the total return index for GE
GE_monthly <-PS1_Monthly %>% 
  group_by(TICKER) %>% 
  filter(TICKER=="GE") %>% 
  mutate(
    
    TR_RET = cumprod(1*(1+RET)),
    TR_RETX = cumprod(1*(1+RETX)),
    TR_SP500 = cumprod(1*(1+sprtrn)),
        
         )

#note that due to duplicated dates, using a cumulative product approach (or a function approach) on sprtrn (to calculate the S&P500 total return) will not produce an accurate total return index

```

**Plotting the Index for MSFT**
```{r plotting_monthly_total_return_index_MSFT, fig.height=7, fig.width=7}

#for MSFT both with and without dividends
ggplot()+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_RET),color="red")+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_RETX),color="blue")+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_SP500),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="MSFT | Microsoft Corporation", subtitle="Monthly Total Return Index <span style='color:red;'>Including Dividends</span>, <span style='color:blue;'>Excluding Dividends</span> and for the <span style='color:gray45;'>S&P500</span></span>",x="Date",y="Total Return")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,120,by=10))+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  theme(plot.subtitle = element_markdown())

```

**Plotting the Index for GE**
```{r plotting_monthly_total_return_index_GE, fig.height=7, fig.width=7}

#for GE both with and without dividends
ggplot()+
  geom_line(data=GE_monthly,aes(x=DATE,y=TR_RET),color="red")+
  geom_line(data=GE_monthly,aes(x=DATE,y=TR_RETX),color="blue")+
  geom_line(data=GE_monthly,aes(x=DATE,y=TR_SP500),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="GE | General Electric Company", subtitle="Monthly Total Return Index <span style='color:red;'>Including Dividends</span>, <span style='color:blue;'>Excluding Dividends</span> and for the <span style='color:gray45;'>S&P500</span></span>",x="Date",y="Total Return")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,16,by=2), limits=c(0,16))+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  theme(plot.subtitle = element_markdown())

```

These two plots clearly demonstrate that including dividends results in a substantially higher total return over time for both stocks surveyed. 

Notably (as we would expect), the divergence of total returns including dividends from total returns excluding dividends increases consistently over the period as the returns accruing from dividends compound. More specifically, for MSFT, the inclusion of dividend payments results in a total return of ~\$115 over the entire period from an initial \$1 investment, over 1.5x greater than the return excluding dividend payments, of just ~\$74. Similarly, for GE, the full-period return including dividends is ~\$10 is 2x greater than that excluding dividend payments, of just \$4.9. 

Thus, arguably dividends have a greater effect on total returns across the full period for GE stock than MSFT stock, despite MSFT having considerably larger total returns overall. Again, this is to be expected, since MSFT only began to issue dividends in January 2003, while GE issued dividends throughout the period surveyed, allowing total returns accruing from dividends to compound over a considerably longer time period. 

# QUESTION 4

> 4.  Normalize the price of GE using the adjusted number of shares. Plot the adjusted price against the unadjusted prices. Discuss.

```{r normalizing_monthly_GE_price, fig.height=7, fig.width=7}

#normalizing the price by adjusting for number of shares
GE_monthly <- GE_monthly %>% 
  mutate(PRC_norm = PRC/CFACPR)

#plotting the adjusted prices against the unadjusted prices
ggplot()+
  geom_line(data=GE_monthly,aes(x=DATE,y=PRC),color="red")+
  geom_line(data=GE_monthly,aes(x=DATE,y=PRC_norm),color="blue")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="GE | General Electric Company", subtitle="<span style='color:red;'>Nominal Price</span> and <span style='color:blue;'>Share-Adjusted Price</span> </span>",x="Date",y="Price")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,160,by=20), limits=c(0,160))+
  theme(plot.subtitle = element_markdown())

```

Reviewing the relationship between GE's nominal and adjusted share prices, it is clear by the steep and immediate drop in nominal share price, to the exact level of the adjusted share price, that there was a stock split. Indeed, this drop from approximately \$160 per share, to approximately \$55 per share, is consistent with GE's 3 for 1 stock split in mid-2000, as discussed in GE's [2000 Annual Report](https://www.annualreports.com/HostedData/AnnualReportArchive/g/NYSE_GE_2000.pdf "2000 Annual Report"){target="_blank"}. 

Alongside the dividend comparison plots above, this demonstrates dividend payments and price adjustment (not just nominal prices) are critical components of assets which must be factored into returns. 

# QUESTION 5

> 5.  The holding period returns are normal returns. Generate a new variable that contains the corresponding log returns (LRET). Calculate the mean, variance, skewness, and kurtosis of the normal and the log returns. Plot the normal against the log returns for MSFT. Briefly discuss your results!

Log returns are calculated as follows:

$LRET = ln(PRC_t/PRC_{t-1}) = ln(1+RET)$,   

where $PRC_t$ is the asset price at time $t$ and $RET=(PRC_t/PRC_{t-1}-1)$

```{r log_monthly_returns}

#creating the log returns variable
PS1_Monthly <- PS1_Monthly %>% 
    mutate(LRET=log(1+RET)) 

#calculating the mean, variance, skewness, and kurtosis of the normal (RET) and the log (LRET) returns
statistics_monthly <- PS1_Monthly %>% 
    group_by(TICKER) %>% 
  
#using the library(PerformanceAnalytics) to calculate the statistics
    summarise(
      
      mean_normal = mean(RET),
      variance_normal = var(RET),
      skewness_normal = skewness(RET),
      kurtosis_normal = kurtosis(RET),
      
      mean_log = mean(LRET),
      variance_log = var(LRET),
      skewness_log = skewness(LRET), 
      kurtosis_log = kurtosis(LRET)
      
      )

print(statistics_monthly)

```

These distributions demonstrate how the logged returns of key assets such as MSFT and GE have a lower kurtosis than the normal returns, and less left-skewed. This is to be expected since taking the log of returns adjusts for the effect of a substantial number of positive outliers. 

Aside from kurtosis and skew (which is represented by the logged mean return being consistently smaller than the normal mean return), the variance of the normal returns and logged returns are similar: the logged return variance being only marginally smaller than the normal return variance, again due to mitgation of the effects of outliers at the positive extreme. 

```{r MSFT_monthly_returns_plot, fig.height=7, fig.width=7}

#(further) adding the total returns LRET series for MSFT
MSFT_monthly <-MSFT_monthly %>% 
  mutate(LRET=log(1+RET))

#plotting normal and log returns for MSFT
ggplot()+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=RET),color="red")+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=LRET),color="blue")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="MSFT | Microsoft Corporation", subtitle="<span style='color:red;'>Normal Returns</span> and <span style='color:blue;'>Log Returns</span> </span>",x="Date",y="Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::percent_format(), breaks=seq(-0.4,0.4,by=0.05), limits=c(-0.4,0.4))+
  theme(plot.subtitle = element_markdown())

```

**Conclusions on Logged vs. Normal Returns**

This plot demonstrates how logged returns closely approximate normal returns. However, consistent with the statistical distributions themselves, normal return peaks are marginally higher than those for logged returns, which adjust for outliers. This means that, statistically, logged returns have marginally lower: mean and variance, less positive (more negative) left skewness and lower kurtosis, than normal returns. 

Ultimately the log formulation is powerful because it allows us to add asset returns in order to estimate total returns over time, greatly simplifying returns analysis. 

# QUESTION 6

> 6. Go to CANVAS and download the data for PS1 Daily.xlsx. This file contains two worksheets. HPR Daily contains the daily holding period returns for the six stocks, the S&P 500 Composite Index and the value-weighted market portfolio (including dividends) from CRSP. Prices Daily contains the prices for the six stocks and the S&P 500 Composite Index.

```{r loading_daily_data}

HPR_daily <- read_xlsx("PS1_Daily.xlsx", sheet = "HPR_daily", skip = 1) %>% 
    mutate(DATE = lubridate::ymd(DATE))  # fix `date`

Prices_daily <- read_xlsx("PS1_Daily.xlsx", sheet = "Prices_daily", skip = 1) %>% 
    mutate(DATE = lubridate::ymd(DATE))  # fix `date`

```

```{r pivoting_data_for_usability}

#pivoting prices daily
Prices_daily_long <-Prices_daily %>% 
  pivot_longer(cols = c(2:8),names_to = "TICKER",values_to = "PRC") 

#pivoting holding period returns
HPR_daily_long <-HPR_daily %>% 
  pivot_longer(cols = c(2:9),names_to = "TICKER",values_to = "RET")

```

# QUESTION 7

> 7. Construct a daily total return index for MSFT and GE stocks and the S&P 500 index and plot them against each other. Compare your results with the monthly total return indices from above. Are there any differences? Discuss.

```{r creating_daily_total_RET_indexes}

#creating MSFT daily total return index
MSFT_daily <-HPR_daily_long %>% 
  group_by(TICKER) %>% 
  filter(TICKER=="MSFT") %>% 
  mutate(TR_RET = cumprod(1*(1+RET)))

#creating GE daily total return index
GE_daily <-HPR_daily_long %>% 
  group_by(TICKER) %>% 
  filter(TICKER=="GE") %>% 
  mutate(TR_RET = cumprod(1*(1+RET)))
    
#creating SP500 daily total return index (this now works, because pivoting longer has removed duplicate date entries)
SP500_daily <-HPR_daily_long %>% 
  group_by(TICKER) %>% 
  filter(TICKER=="SPRTRN") %>% 
  mutate(TR_RET = cumprod(1*(1+RET)))
    
```

## Monthly Total Return Indexes

**Plotting the Monthly Total Return Index for MSFT**
```{r monthly_total_return_index_MSFT, fig.height=10, fig.width=10}

#(monthly) plotting MSFT in comparison to the SP500
monthly_returns_MSFT <- ggplot()+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_RET),color="orange")+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_SP500),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="MSFT | Monthly Total Returns Comparison", subtitle="Monthly Total Returns Index for <span style='color:orange;'>MSFT</span> and the <span style='color:gray45;'>S&P500</span> </span>",x="Date",y="Total Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,120,by=10), limits=c(0,120))+
  theme(plot.subtitle = element_markdown())

```

**Plotting the Monthly Total Return Index for GE**
```{r monthly_total_return_index_GE, fig.height=10, fig.width=10}

#(monthly) plotting GE in comparison to the SP500
monthly_returns_GE <- ggplot()+
  geom_line(data=GE_monthly,aes(x=DATE,y=TR_RET),color="purple")+
  geom_line(data=MSFT_monthly,aes(x=DATE,y=TR_SP500),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="GE | Monthly Total Returns Comparison", subtitle="Monthly Total Returns Index for <span style='color:purple;'>GE</span> and the <span style='color:gray45;'>S&P500</span> </span>",x="Date",y="Total Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,15,by=1), limits=c(0,15))+
  theme(plot.subtitle = element_markdown())

```

## Daily Total Return Indexes

**Plotting the Index for MSFT**
```{r plotting_daily_total_return_index_MSFT, fig.height=10, fig.width=10}

#(daily) plotting MSFT and GE in comparison to each other and SP500
daily_returns_MSFT <- ggplot()+
  geom_line(data=MSFT_daily,aes(x=DATE,y=TR_RET),color="orange")+
  geom_line(data=SP500_daily,aes(x=DATE,y=TR_RET),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="MSFT | Daily Total Returns Comparison", subtitle="Daily Total Returns Index for <span style='color:orange;'>MSFT</span> and the <span style='color:gray45;'>S&P500</span> </span>",x="Date",y="Total Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,120,by=10), limits=c(0,120))+
  theme(plot.subtitle = element_markdown())

```

**Plotting the Index for MSFT**
```{r plotting_daily_total_return_index_GE, fig.height=10, fig.width=10}

#(daily) plotting MSFT and GE in comparison to each other and SP500
daily_returns_GE <- ggplot()+
  geom_line(data=GE_daily,aes(x=DATE,y=TR_RET),color="purple")+
  geom_line(data=SP500_daily,aes(x=DATE,y=TR_RET),color="gray45")+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="GE | Daily Total Returns Comparison", subtitle="Daily Total Returns Index for <span style='color:purple;'>GE</span> and the <span style='color:gray45;'>S&P500</span> </span>",x="Date",y="Total Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,15,by=1), limits=c(0,15))+
  theme(plot.subtitle = element_markdown())

```


```{r plotting_total_return_indexes, fig.height=10, fig.width=20}

#plotting the two alongside one another
(daily_returns_MSFT+monthly_returns_MSFT)/(daily_returns_GE+monthly_returns_GE)

```

Comparing the daily and monthly total return indexes shown above, it is clear that each asset demonstrates identical trends over the course of the period, though (as we would expect) the daily returns index exhibits considerably greater price volatility, which is smoothed by monthly returns calculations. 

# QUESTION 8

> 8. As before, the holding period returns are normal returns. Create log returns. Calculate the mean, variance, skewness, and kurtosis of the normal and log returns. Compare and discuss your results with the results from monthly frequency.

```{r log_daily_returns}

#creating the log returns variable, LRET = ln(1+RET) = ln(PRC/lag(PRC))
HPR_daily_long <-HPR_daily_long %>% 
  mutate(LRET=log(1+RET))

#calculating the mean, variance, skewness, and kurtosis of the normal (RET) and the log (LRET) returns
statistics_daily <- HPR_daily_long %>% 
    group_by(TICKER) %>% 
  
#using the library(PerformanceAnalytics) to calculate the statistics
    summarise(
      
      mean_normal = mean(RET),
      variance_normal = var(RET),
      skewness_normal = skewness(RET),
      kurtosis_normal = kurtosis(RET),
      
      mean_log = mean(LRET),
      variance_log = var(LRET),
      skewness_log = skewness(LRET), 
      kurtosis_log = kurtosis(LRET)
      
      )

#comparing daily and monthly normal and logged statistics
print(statistics_daily)
print(statistics_monthly)

```

**Conclusions on Logged vs. Normal Returns for DAILY vs. MONTHLY Returns**

As for Monthly returns, we find that logged daily returns demonstrate marginally lower: mean and variance, less positive (more negative) left skewness and lower kurtosis, than normal returns. 

As would be expected, relative to monthly returns, normal daily returns have a considerably lower mean and variance, are much more strongly positively (left) skewed, and have considerably higher kurtosis. 

Evidently, calculation of (normal) returns on a *monthly basis* not only smooths out price volatility (variance), but results in a distribution which more *closely approximates the normal distribution* (no leptokurtosis or 'fat tails', no substantive positive or negative skew). 

# QUESTION 9 

> 9.  Compare the statistical properties of the log holding period return time series both for monthly and daily returns. Plot a histogram and discuss how the empirical distributions relate to the normal distribution.

**Logged Monthly Distribution**
```{r logged_monthly_distribution, fig.height=10, fig.width=10}

distribution_log_monthly <- PS1_Monthly %>% 
  ggplot(aes(x = LRET))+
  geom_histogram(binwidth = 0.01, fill="pink")+
  facet_wrap(~TICKER)+
  theme_fivethirtyeight()+
  theme(axis.title=element_text())+
  labs(title="Monthly Log Return Distribution",subtitle="Comparing the Distribution of Monthly and Daily Log Returns",x="Log Return",y="Frequency")+
  scale_x_continuous(breaks=seq(-0.5,0.5,0.1),limits=c(-0.5,0.5))

```

**Logged Daily Distribution**
```{r logged_daily_distribution, fig.height=10, fig.width=10}

distribution_log_daily <- HPR_daily_long %>% 
  ggplot(aes(x = LRET))+
  geom_histogram(binwidth = 0.01, fill="pink")+
  facet_wrap(~TICKER)+
  theme_fivethirtyeight()+
  theme(axis.title=element_text())+
  labs(title="Daily Log Return Distribution",subtitle="Comparing the Distribution of Monthly and Daily Log Returns",x="Log Return",y="Frequency")+
  scale_x_continuous(breaks=seq(-0.5,0.5,0.1),limits=c(-0.5,0.5))

```

**Comparing the Returns Distributions**
```{r logged_returns_comparison, fig.height=7, fig.width=15}

distribution_log_monthly+distribution_log_daily

```

For a better comparison, we compare the monthly and daily logged returns of MSFT::

**MSFT | Log Returns Comparison**
```{r MSFT_log_returns_distribution, fig.height=10, fig.width=7}

#specifying GE monthly log distribution
MSFT_log_dist_monthly <- PS1_Monthly %>% 
  filter(TICKER=="MSFT") %>% 
  ggplot(aes(x = LRET))+
  geom_histogram(binwidth = 0.01, fill="orange")+
  theme_fivethirtyeight()+
  theme(axis.title=element_text())+
  labs(title="Monthly Log Return Distribution",subtitle="MSFT | Microsoft Corporation",x="Log Return",y="Frequency")+
  scale_x_continuous(breaks=seq(-0.5,0.5,0.1),limits=c(-0.5,0.5))

#specifying GE daily log distribution
MSFT_log_dist_daily <- HPR_daily_long %>% 
  filter(TICKER=="MSFT") %>% 
  ggplot(aes(x = LRET))+
  geom_histogram(binwidth = 0.01, fill="orange")+
  facet_wrap(~TICKER)+
  theme_fivethirtyeight()+
  theme(axis.title=element_text())+
  labs(title="Daily Log Return Distribution",subtitle="MSFT | Microsoft Corporation",x="Log Return",y="Frequency")+
  scale_x_continuous(breaks=seq(-0.5,0.5,0.1),limits=c(-0.5,0.5))

#outputting the two distributions
MSFT_log_dist_monthly/MSFT_log_dist_daily

```

Though the daily returns distributions above appear to be more normally distributed than those for monthly returns, due to their regular narrow "bell" shape, since there are comparatively many observations at each extreme, the daily log returns distribution is too leptokurtic (kurtosis is too high) to be normally distributed. Thus, as concluded in Question 8, monthly returns (whether logged or not) better approximate the normal distribution than daily returns. This implies that the normal distribution assumption is more likely to hold for lower frequency returns, such as monthly, rather than daily, returns. 

# QUESTION 10

> 10.  Pick three stocks and the S&P 500 index (either you can use MSFT, GE and JPM or adapt the code to pick three random stocks). You will need the holding period returns (both normal and log returns) and the total return indices you created.

We prepare the stocks data including: (I) holding period returns (RET); (II) log holding period returns (LRET); (III) total returns (TR_RET); (IV) total log returns (TR_LRET); (V) total returns from exp(log) (TR_RETEXP); and (VI) squared log returns (SQ_LRET).

```{r preparing_the_stocks}

#we select MSFT, GE and JPM and create a dataframe including HPR, LRET and TR_RET (total return), calculated by summing logged returns
stocks <- HPR_daily_long %>% 
  filter(TICKER == "GE"|
         TICKER == "JPM"|
         TICKER == "MSFT"|
         TICKER == "SPRTRN") %>% 
  group_by(TICKER) %>% 
  mutate(
    
    #log total return
    TR_LRET = cumsum(LRET),
    #normal total return
    TR_RET = cumprod(1*(1+RET)),
    #normal total return calculated from exp(log) - used to double-check that TR_RET is accurate (which it is)
    TR_RETEXP = exp(TR_LRET),
    #squared log returns
    SQ_LRET = log(1+RET)^2
      
    ) %>% 
  select(1,2,3,6,4,5,7,8)

```

# QUESTION 11

> 11.  Calculate the covariance matrix for the log return series, using both the returns and returns squared. Discuss your results briefly.

**Log Returns Covariance Matrix**
```{r log_cov}

stocks %>% 
  select(1,2,5) %>% 
  pivot_wider(names_from="TICKER",values_from="LRET") %>% 
  select(-1) %>% 
  cov() %>% 
  round(6)

```

**Squared Log Returns Covariance Matrix**
```{r log_sq_cov}

stocks %>% 
  select(1,2,8) %>% 
  pivot_wider(names_from="TICKER",values_from="SQ_LRET") %>% 
  select(-1) %>% 
  cov() %>% 
  round(8)

```

The two covariance matrices demonstrate that positive covariance exists between each pair of assets (the three chosen stocks, or the S&P 500) in terms of both log returns and log returns squared, indicating a consistently positive relationship. This means that all 3 selected stocks are likely to move in the same direction as eachother, and as the S&P500, when responding to market conditions. Notably, the covariance of the log return squared matrix is over 1/100 smaller than the corresponding log return matrix, thereby indicating a weaker positive relationship between the returns of each asset. 

Within the 3 stocks picked, JPM has the strongest relationship with S&P 500, and JPM and GE are the most strongly correlated of the stocks, in terms of their logged returns. This implies that, in order to optimally diversify away idiosyncratic risk, a portfolio should not include JPM if it is to include MSFT, GE or S&P500 - and that, of the chosen stocks, MSFT is least correlated in its returns with both the other stocks and thus likely to be the best addition to a diversified portfolio. 

However, we cannot rely fully on these covariances to draw inferences regarding the optimal portfolio. This is because the magnitude of covariance can be heavily skewed whenever the data set includes too many significantly different values: single outliers (which remain present in the logged returns, though to a lesser extent than normal returns) can cause dramatic under or overstatement of the relationship between asset returns. 

# QUESTION 12

> 12. Plot the ACF (autocorrelation function) for prices, returns, returns squared, and absolute returns. Discuss the results!

## Monthly (not daily) asset data is used throughout this question, and the ACF is plotted for each of the 3 chosen stocks (MSFT, GE, JPM)

### For MSFT
```{r MSFT_ACF, fig.height=4, fig.width=4}

#preparing the data for ACF
MSFT_monthly_ACF <- PS1_Monthly %>% 
  filter(TICKER=="MSFT") %>% 
  #date, price, return
  select(3,9,10) %>% 
  mutate(
    
    #returns squared
    RET_SQ = RET^2,
    #absolute returns
    RET_ABS = abs(RET)
    
  )

#I employ a maximum lag covering the full period (25 years = 300 months)

#plotting the ACF for prices
price_MSFT <- acf(MSFT_monthly_ACF$PRC,lag.max=300,plot=FALSE)
plot(price_MSFT, main = "ACF of MSFT Monthly Prices") 

#plotting the ACF for returns
return_MSFT <- acf(MSFT_monthly_ACF$RET,lag.max=300,plot=FALSE)
plot(return_MSFT, main = "ACF of MSFT Monthly Returns") 

#plotting the ACF for returns squared
returnsq_MSFT <- acf(MSFT_monthly_ACF$RET_SQ,lag.max=300,plot=FALSE)
plot(returnsq_MSFT, main = "ACF of MSFT Monthly Returns Squared") 

#plotting the ACF for absolute returns
absolute_MSFT <- acf(MSFT_monthly_ACF$RET_ABS,lag.max=300,plot=FALSE)
plot(absolute_MSFT, main = "ACF of MSFT Monthly Absolute Returns") 

```

### For GE

```{r GE_ACF, fig.height=4, fig.width=4}

#preparing the data for ACF
GE_monthly_ACF <- PS1_Monthly %>% 
  filter(TICKER=="GE") %>% 
  #date, price, return
  select(3,9,10) %>% 
  mutate(
    
    #returns squared
    RET_SQ = RET^2,
    #absolute returns
    RET_ABS = abs(RET)
    
  )

#I employ a maximum lag covering the full period (25 years = 300 months)

#plotting the ACF for prices
price_GE <- acf(GE_monthly_ACF$PRC,lag.max=300,plot=FALSE)
plot(price_GE, main = "ACF of GE Monthly Prices") 

#plotting the ACF for returns
return_GE <- acf(GE_monthly_ACF$RET,lag.max=300,plot=FALSE)
plot(return_GE, main = "ACF of GE Monthly Returns") 

#plotting the ACF for returns squared
returnsq_GE <- acf(GE_monthly_ACF$RET_SQ,lag.max=300,plot=FALSE)
plot(returnsq_GE, main = "ACF of GE Monthly Returns Squared") 

#plotting the ACF for absolute returns
absolute_GE <- acf(GE_monthly_ACF$RET_ABS,lag.max=300,plot=FALSE)
plot(absolute_GE, main = "ACF of GE Monthly Absolute Returns") 

```

### For JPM

```{r JPM_ACF, fig.height=4, fig.width=4}

#preparing the data for ACF
JPM_monthly_ACF <- PS1_Monthly %>% 
  filter(TICKER=="JPM") %>% 
  #date, price, return
  select(3,9,10) %>% 
  mutate(
    
    #returns squared
    RET_SQ = RET^2,
    #absolute returns
    RET_ABS = abs(RET)
    
  )

#I employ a maximum lag covering the full period (25 years = 300 months)

#plotting the ACF for prices
price_JPM <- acf(JPM_monthly_ACF$PRC,lag.max=300,plot=FALSE)
plot(price_JPM, main = "ACF of JPM Monthly Prices") 

#plotting the ACF for returns
return_JPM <- acf(JPM_monthly_ACF$RET,lag.max=300,plot=FALSE)
plot(return_JPM, main = "ACF of JPM Monthly Returns") 

#plotting the ACF for returns squared
returnsq_JPM <- acf(JPM_monthly_ACF$RET_SQ,lag.max=300,plot=FALSE)
plot(returnsq_JPM, main = "ACF of JPM Monthly Returns Squared") 

#plotting the ACF for absolute returns
absolute_JPM <- acf(JPM_monthly_ACF$RET_ABS,lag.max=300,plot=FALSE)
plot(absolute_JPM, main = "ACF of JPM Monthly Absolute Returns") 

```

Autocorrelation indicates the degree of correlation of the same variables between two successive time intervals. The plots above have lag numbers on the x-axis and degree of ACF on the y-axis, demonstrating different levels of autocorrelation between time series data when the lag is set to different values (with a maximum value of 300 months).

**ACF for Price**
Evidently, MSFT and GE stocks demonstrate a similar price ACF, by which, the longer the lagged period, the lower the autocorrelation - until the autocorrelation becomes negative (due to the boom and bust cyles of markets). Subsequently, as the period lag increases further, the price becomes totally uncorrelated with the initial time interval, which is to be expected as such large time lags result in the accumulation of unpredictable and uncorrelated price influences. However, JPM shows a different, more cyclical trend (most likely because its share price performance is more closely correlated with core market drivers), by which the share price cycles between positive and negative autocorrelation as the lagged period increases, with almost no subsequent periods being entirely uncorrelated with the price at the initial time interval. 

**ACF for Returns (Normal, Squared, Absolute)**
Interestingly, the ACF functions demonstrate how while normal returns do not appear to follow a cyclical pattern, both squared and absolute returns demonstrate considerable cyclicality for all 3 stocks surveyed. For these returns transformations, we find that while autocorrelation falls steeply as the lag increases, after 10-20 lagged periods, there is considerably more regularity and cyclicality in the ACF. 

This indicates that, while normal returns do not follow a particularly regular pattern as the lagged period increases, squared and absolute returns (on the basis of greater cyclicality alternating between positive and negative autocorrelation as the lag increases) demonstrate a far more predictable sequence. Consequently, it appears that squared and absolute returns are far more predictable (especially for consistently periodic stocks like GE) than normal returns or price. 

# QUESTION 13

> 13. Use the three assets and make up a portfolio by assigning arbitrary portfolio weights. What does it imply if you keep the weights fixed over time?


Since the portfolio weight of a given asset $\mathbb{X}$ is represented by the value of the asset as a proportion of the value of the entire portfolio, and the asset value fluctuates constantly, by keeping the portfolio weights fixed, we must constantly re-balance our portfolio. 

```{r assigning_portfolio_weights}

MSFT_weight = 0.4
GE_weight = 0.3
JPM_weight = 0.3

```

# QUESTION 14

> 14.  Calculate the portfolio returns and use them to calculate the evolution of a $1 investment in the portfolio over the sample period. Plot the result against the evolution of a $1 investment in each of the three stocks. Discuss the result.

Since 'stocks' contains all the required data, we must now manipulate to extract the required total returns.

```{r calculating_portfolio_returns}

#preparing the total returns by stock in wide format
portfolio_stocks <- stocks %>% 
  select(1,2,4) %>% 
  pivot_wider(names_from="TICKER",values_from="TR_RET") %>% 
  select(1:4)

#creating a new column containing the weighted sum of these total individual stock returns
PTFOLIO <- portfolio_stocks %>% 
  mutate(
    
    Portfolio = (MSFT*MSFT_weight + GE*GE_weight + JPM*JPM_weight)
    
  )
  
```

```{r plotting_portfolio_returns, fig.height=7, fig.height=7}

#transforming the dataset from wide to long format again and plotting the results
PTFOLIO %>% 
  pivot_longer(cols=c(2:5),names_to="Asset",values_to="TR_RET") %>%
  
  #plotting the returns
  ggplot(aes(x=DATE,y=TR_RET,color=Asset))+
  geom_line()+
  theme_fivethirtyeight() + theme(axis.title=element_text())+
  labs(title="Portfolio Returns Against Stock Returns", subtitle="The Evolution of a $1 Investment in a Weighted Portfolio of MSFT (0.4), GE (0.3) and JPM (0.3) Against the Underlying Stocks",x="Date",y="Total Return")+
  scale_x_date(date_breaks="2 years",date_labels="%Y")+
  scale_y_continuous(labels=scales::dollar_format(), breaks=seq(0,120,by=10), limits=c(0,120))+
  theme(plot.subtitle = element_markdown(), legend.position="top")

```

This plot implies that the portfolio composed of a weighted sum of the three stocks has a higher risk-to-reward (Sharpe) ratio, relative to each of the individual stocks.

Indeed, while both GE and JPM have relatively low risk (low variance/volatility) and low reward (with a total return of less than 20x over the period), MSFT has extremely high reward (110x return), at high risk. Contrastingly, the collective portfolio demonstrates considerably lower variance than MSFT stock, while generating approximately half the returns. 

This means that investing in the weighted portfolio is more favourable for risk-averse, return-maximising investors than any of the individual stocks which compose it. 

# QUESTION 15

> 15.  Portfolio theory with matrix algebra

> 15.a Calculate the means, the variance and the pairwise covariances for the three stocks MSFT, GE, and JPM for the sample period between 2/1/1990 and 31/12/2002.


```{r mean, variance, covariance}

# Using dplyr to select the 3 stocks (MSFT, GE, JPM) for dates b/w period 2/1/1990 and 31/12/2002

Prices_daily_filtered <- Prices_daily %>% 
  select(-c("XOM", "INTC", "C")) %>% 
  filter(DATE >= "1990-01-02" & DATE <= "2002-12-31")

# Calculating the Mean, Variance and Pairwise Covariance for the three stocks

summary_stats <- Prices_daily_filtered %>% 
  summarise(mean_MSFT = mean(MSFT), var_MSFT = var(MSFT),
            mean_GE = mean(GE), var_GE = var(GE),
            mean_JPM = mean(JPM), var_JPM = var(JPM))

# MSFT has the highest mean and lowest variance whereas, 
# JPM has the lowest mean and highest variance

covariance_matrix <- var(Prices_daily_filtered
    %>% select(c("MSFT", "JPM", "GE")))

# We can see that JPM and MSFT have the highest pairwise correlation across all 3 combinations
```

> 15.b Define the following matrices that contain returns, expected returns, portfolio weights, and covariances:

> 15.c Note that the expected portfolio return and variance equal: Further, the condition that the portfolio weights have to sum up to one can be expressed as x’1= 1.

```{r defining the matrices}

# Defining the return -- 3280x3 matrix
R <- as.matrix(Prices_daily_filtered %>% 
  select(c("MSFT", "JPM", "GE"))) # check if this is the correct matrix form
  
# Defining the expected return (mu) -- 3x1 matrix
mu <- matrix(t((summary_stats %>% 
  select(c(1, 3, 5)))))

# Defining portfolio with equal weights -- 3x1 matrix
x <- matrix(rbind(0.33, 0.33, 0.33))

# Defining the covariances (sigma) -- 3x3 matrix
sigma <- as.matrix(covariance_matrix)

```

> 15.d Calculate the return and standard deviation of a portfolio where you equal-weight the three stocks - call the portfolio e. Additionally, consider a portfolio y with a weight vector y’ = (0.8, 0.4, −0.2). 
Calculate the risk-return tradeoff of y as well as its covariance with portfolio e.

```{r calculating return and sd}

# Formulating portfolio E with equal weights 
return_portfolio_e <- t(x) %*% mu
return_portfolio_e

# The return on the portfolio is 70.85

sd_portfolio_e <- t(x) %*% sigma %*% x
sqrt(sd_portfolio_e)

# The risk / standard deviation on the portfolio is 21.922

# Formulating portfolio Y with variable weights 

y_dash <- matrix(rbind(0.8, 0.4, -0.2))

return_portfolio_y <- t(y_dash) %*% mu
return_portfolio_y
# The return on the portfolio is 89.53

sd_portfolio_y <- t(y_dash) %*% sigma %*% y_dash
sqrt(sd_portfolio_y)
print(sigma)
# The risk / standard deviation on the portfolio is 26.26

# Risk-return trade-off can be measured using the Sharpe Ratio

# TO BE DONE -- Calculating the risk-return tradeoff of y 

# library for the Sharpe Ratio
library("PerformanceAnalytics") 

SharpeRatio(return_portfolio_y, Rf = 0, FUN = "StdDev")


# Covariance of Y with portfolio E
cov_e_y <- t(x) %*% sigma %*% y_dash
```

> 15.e In order to find the global minimum variance portfolio with weights m’ = (mMSF T , mGE, mJPM ), we have to solve the following problem. The first three elements ofzmare the portfolio weightsm’= (mMSF T, mGE, mJP M) for the globalminimum variance portfolio. Calculate the variance and the expectedreturn of the minimumvariance portfolio.

```{r global minimum variance portfolio}

# Defining matrix A -- 4 x 4 matrix
A <- rbind(cbind(2*sigma,c(1,1,1)),c(1,1,1,0)) 

# Defining matrix B -- 4 x 1 matrix
B <- cbind(c(0, 0, 0, 1))

# Defining matrix Z
Z <- solve(A) %*% B # solve() is used to find the inverse

# Weights of global minimum variance portfolio
m <- Z[1:3]

# Return of global minimum variance portfolio
return_portfolio_global_min <- t(m) %*% mu
return_portfolio_global_min

# Variance of global minimum variance portfolio
variance_portfolio_global_min <- t(m) %*% sigma %*% m
sqrt(variance_portfolio_global_min)

```

> 15.f Find another efficient portfolio. Namely, the efficient portfolio that gives a return equal to the expected return of MSFT. Note, that your minimization problem now becomes:

> 15.g Derive the solution as above in terms of portfolio weights and calculate them in your code. In addition, calculate the expected return and the variance of efficient portfolio x as well as its covariance with the global minimum portfolio.

```{r another efficienct portfolio}
# Defining matrix A -- 5 x 5 matrix
A <- rbind(cbind(2*sigma, mu, c(1,1,1)),c(mu, 0, 0),c(1,1,1,0,0)) 

# Defining matrix B -- 5 x 1 matrix
B <- cbind(c(0, 0, 0, mu[1], 1))

# Defining matrix Z
Z <- solve(A) %*% B # solve() is used to find the inverse

# Weights of global minimum variance portfolio
m <- Z[1:3]

# Return of global minimum variance portfolio
return_portfolio_global_min <- t(m) %*% mu
return_portfolio_global_min

# Variance of global minimum variance portfolio
variance_portfolio_global_min <- t(m) %*% sigma %*% m
sqrt(variance_portfolio_global_min)
```


> 15.h Plot the entire efficient frontier for the three risky assets.

> 15.i Now, rerun your code with sample moments for the three stocks MSFT, GE, and JPM for the sample period between 2/1/2003 and 31/12/2014.

> 15.j Finally, compare your results for the three assets across the two sample periods. Comment on
potential problems that might arise when you based investment decisions on your analysis. Also
discuss potential solutions to the problems mentioned.















